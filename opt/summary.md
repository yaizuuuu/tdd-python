# 各章の要約

## 25章

### 独立したテスト

テストは独立している状態に保つべきである。
そのメリットは以下の様なものがある。

* テストを独立させるためにメソッドなどを小さく分割することによって、準備が簡単になりテスト実行の速度上がる
* 独立したテストを心がけると、凝集度が高く、結合度の低い小さなオブジェクトをたくさんつくるようになるため、良い設計になる

### TODOリスト

TODOリストを充実させるプロセスは以下のような手順になる。

1. 実装しなければならない振る舞いを考えられるだけ書き出してみる
2. 空実装をリストに加える
3. リファクタリングをしなければならない箇所をすべて書き出しておく

### テストファースト

実装を終えてしまったら、きっとテストはあとからは書かれない。

### アサートファースト

アサートを最初に書くことによって以下を最初に考える流れになる。

* 正しい結果とは何か
* それをどう検証するのか

## 26章

### 回帰テスト

不具合が報告されたとき、不具合を再現させる最小のテストケースを書き、失敗を確認する。
それが回帰テストである。
回帰テストは本来コードを書いたときに同時に書かれるものなので、書くべきだったことにどうやったら気づけたのか振り返ら泣けばならない。

### 休憩

何を書くべきか明確に分かっているときは明白な実装を行う。
分からないときは仮実装を行う。
まだ正しい実装が見えてこない場合は三角測量を行う。
それでも分からないときは休憩に行く。

### やり直す

手詰まりになって、途方に暮れてしまったときは、コードを捨ててやり直す。
どんどん進めてしまうとその分だけ無駄になる可能性がある。

## 27章

### 小さいテスト

あまりにも大きくなってしまったテストが失敗したときは、大きいテストから問題箇所を絞り込んだ小さいテストを書く。
レッド・グリーン・リファクタリングのリズムの生命線を死守する。

### Mock Object パターン

構築処理や準備に手間がかかるオブジェクトにはモックを使う。
極力本物のデータベースは使わない。
モックを使うとコードの結合度を低く抑えることに繋がる。

### Crash Test Dummy パターン

例外をテストするパターン。
サンプルのコードはファイルシステムが限界容量まで達しているときにアプリケーションに何が起きるかをテストしている。

```java
private class FullFile extends File {
    public FullFile(String path) {
        super(path);
    }
    
    public boolean createNewFile() throws IOException {
        throw new IOException();
    }
}

```

## 29章

### アサーション

テストは具体的に書く。

×：`asserTrue(rectangle.area() != 0)`

◯：`assertEquals(rectangle.area(), 50)`

オブジェクトの変数までテストしたくなるときは、設計を改善する機会である。

## 30章

### Pluggable Object パターン

特定の条件により移譲先のオブジェクトを分ける。
移譲先のオブジェクトは同じインターフェースを継承しており、呼び出しは変わらないが、振る舞いが異なる。
ポリモーフィズムを利用したパターンである。

```java
class Test {
    Figure selected;
    SelectionMode mode;
    
    public void mouseDown() {
        selected  = findFigure();
        if (selected != null)
            mode = new SingleSelection(selected);
        else
            mode = new MultipleSelection();
    }
    
    public void mouseMove() {
        mode.mouseMove();
    }
    
    public void mouseUp() {
        mode.mouseUp();
    }
}
```

## 31章

### データ構造の変更

データの持ち方を変えるには以下のやり方がある。

1. 新構造のためのインスタンス変数を定義する
2. 旧構造でデータが設定されている部分をその変数に置き換える
3. 旧構造のデータを使っている部分をその変数に置き換える
4. 旧構造のコードを消す
5. 外部インターフェイスに新構造を反映する

API側から変更を行う場合は以下のやり方がよい

1. 新構造のパラメータを追加する
2. 新構造のパラメータを内部で旧構造に変換する
3. 旧構造のパラメータを削除する
4. 旧構造を使っている部分を新構造に置き換えていく
5. 旧構造のコードを削除する

## 32章

### 一歩の大きさはどのくらいか

小さいステップに分割することを心がける。
そういった小さいステップを何度も繰り返し、初めていくつかのステップをスキップしてみる。
一般的に、変更の量は変更の質に影響を及ぼすからだ。

### テストしなくてもよいものはあるか

不安が退屈に変わるまでテストを書くところまでが目安になる。
答えは自分で探す必要がある。

しかし、テストしなくてはならないところを上げるとすれば、以下が挙げられる。

* 条件分岐
* ループ
* 操作
* ポリモーフィズム

### 良いテストを見分けることができるか

設計に問題を抱えている場合、テストには以下のような兆候が現れる

#### 前準備に要するコードが長い

アサーションを行うための準備に100行も要するようであれば、オブジェクトが大きすぎるため分割したほうが良い

#### 前準備の重複

共通の前準備コードを配置する場所がすぐに見つからない場合は。互いが密に関連し合うオブジェクトが多すぎることを示唆している

#### テスト実行時間が長い

テストの実行時間が長いとテストが実行されなくなる。
また、アプリケーションの一部を切り出すことが難しいということ示唆している。

#### 脆いテスト

思わぬタイミングで失敗するテストはアプリケーションが意外な形で他の部分に影響している可能性を示唆する。

### 
